#!/usr/bin/env python3 
print("---Пример 1: Чтение и запись в файл ---")
# Считывание и запись информации в файл 
# функция работы с файлами - open(file [, mode=’r’, encoding=None, …])

# file – это путь к файлу вместе с его именем;
# mode – режим доступа к файлу;
# encoding – кодировка файла.

try:
    file = open("file.txt")
    # по умолчанию файл открывается как чтение (mode = "r")
    # для записи в файл необходимо явно указывать вторым параметром "w" 
    # у файлового объекта имееися внутренний указатель file position 
    # чтение файла , в скобках модно указывать число символов для чтения
    # повторный вызов будет продолжен с места которым закончен вызов один
    # что бы убрать между вызовами пробел, использую sep=""
    
    print(file.read(5), file.read(10), sep="")
    file.close()
except FileNotFoundError:
    print("File is not found")

# --- В Python имеются следующие режимы доступа: ---

# "r" - открытие на чтение (значение по умолчанию)
# "w" - открытие на запись (содержимое файла удаляется, а если его нет, 
    # то создается новый)
# "x" - открытие файла на запись, если его нет генерирует исключение
# "a" - открытие на дозапись (информация добавляется в конец файла)

# --- Дополнения --- 

# "b" - открытие в бинарном режиме доступа к информации файла
# "t" - открытие в текстовом режиме доступа (если явно не указывается, 
    #то используется по умолчанию)
# "+" - открытие на чтение и запись одновременно

# --- Чтение информации из файла --- 

# у файлового объекта имееися внутренний указатель file position 
# В Python можем управлять этой файловой позицией с помощью метода
# seek(offset[, from_what])
# file.seek(0) - означает устанавку позиции в начало 
# pos = file.tell() - узнать текущую позицию в файле
# s = file.readline() - построчно считывать информацию

# для прочитывания файла построчно 

# for line in file:
#        print( line, end="" )

# s = file.readlines() - переменная s будет ссылаться на упорядоченный 
# список с этими строками
# file.close() - после завершения работы с файлом, его следует закрыть

print("\n")
print("--- пример 2 ---")

try:
    file = open("file.txt")
   
    try:
        s = file.readlines()
        print( s )
    finally:
        file.close()

except FileNotFoundError:
    print("Невозможно открыть файл")


print("\n")
print("--- Пример 3: закрытие файлы с использованием блока with ---")
# при использовании блока with беспокоится о закрытии file.close()
# не стоит, это делается автоматически
try:
    with open("file.txt", "r") as file:     
    # file = open("myfile.txt")
        s = file.readlines()
        print( s )

except FileNotFoundError:
    print("Невозможно открыть файл")


print("\n")
print("--- Пример 4: Запись информации в файл  ---")

# первостепенно необходимо открыть файл на запись (параметр - "w")
file = open("example4.txt", "w")
# далее вызывается метод write
file.write("Пример записанного текста  в файл")
file.close()
file = open("example4.txt", "r")
s = file.read()
print(s)
# после закрытия в файл нет доступа
# пример повторной записи в файл который откроем заново


print("\n")
print("---Пример 5: повторная запись в файл  ---")

file = open("example5.txt", "w")
file.write("Пример повторной записи в файл затерает старую ")
file.close()
file = open("example5.txt", "r")
t = file.read()
print(t)
file.close()
# пример повторной записи информация в файл является перезаписанной

print("\n")
print("--- Пример 6: Дозпись в файл с сохранением предыдущего  ---")
# Дабы осуществить дозапись в файл с сохранием предыдущей информации а 
# файле необходимо нередать не обязательный параметр "a"
# При необходимости так же чтения и дозаписи испротзуется "a+"

file = open("example6.txt" , "w")
file.close()
# сдесь создадим файл , или отчистим уже имеющийся
# так как передаем параметр "w"
# далее закроем что бы открыть в дальнейшем для примера чистый файл

file = open("example6.txt" , "a+")
file.write("first line \n")
file.write("second line \n")
file.write("third line \n")
file.seek(0)
print("прочесть все содержимое: \n", file.read())
file.seek(0)
print("прочесть только первую строку \n", file.readline())
# при выводе как коллекция, будет только 2 элемента , так как перед 
# чтением мы не сбросили позиционирование 
print("прочесть все строки и вывести как коллекцию \n", file.readlines())
# на данный момент каждый раз запуская скрипи будет всё больше информации
# пример показывает что после чтения какого либо отрезка 
# всего файла, только строки  или всех строк 
# необходимо сбрасывать указатель иначе не указатель будет на прочитанном


print("\n")
print("--- Пример 7: чтение и запись в бинарном режиме доступа  ---")
# в бинарном режиме доступа, считывание из файлы происходит без какой 
# либо обработки 
# Используется для сохранения с считывания объектов
# Для работы с бинарными данными необходимо подключить специальный 
# встроенный модуль pickle

import pickle

book1 = ["Евгений Онегин", "Пушкин А.С.", 200]
book2 = ["Муму", "Тургенев И.С.", 250]
book3 = ["Мастер и Маргарита", "Булгаков М.А.", 500]
book4 = ["Мертвые души", "Гоголь Н.В.", 190]
try:
    file = open("out1.bin", "wb")
    try:
        pickle.dump(book1, file)
        pickle.dump(book2, file)
        pickle.dump(book3, file)
        pickle.dump(book4, file)
    finally:
        file.close()
except FileNotFoundError:
    print("Невозможно открыть файл")

file = open("out1.bin", "rb")
b1 = pickle.load(file)
b2 = pickle.load(file)
b3 = pickle.load(file)
b4 = pickle.load(file)
print(b1, b2, b3, b4, sep="\n")


# Задания для самоподготовки

# 1. Выполните считывание данных из текстового файла через символ и 
# записи прочитанных данных в другой текстовый файл. Прочитывайте так 
# не более 100 символов.

# 2. Пользователь вводит предложение с клавиатуры. Разбейте это 
# предложение по словам (считать, что слова разделены пробелом) и 
# сохраните их в столбец в файл.

# 3. Пусть имеется словарь:

# d = {"house": "дом", "car": "машина",
#     "tree": "дерево", "road": "дорога",
#     "river": "река"}

#Необходимо каждый элемент этого словаря сохранить в бинарном файле 
# как объект. Затем, прочитать этот файл и вывести считанные объекты в 
# консоль.
