#!/usr/bin/env python3

# Итераторы и выражения-гинераторы
# пример гинератора списка 
a = [x**2 for x in range(10)]
print(a, type(a))

# выражения генераторы льдичаются только круглыми скобками
a = (x**2 for x in range(10))
# результат переменная ссылающаяся на объект-герератор
print(a, type(a))

# Генератор - итератор, элементы которого можно перебировать (итерировать)
# только один раз.

# Итератор - это объект, который поддерживает функцию next() для перехода 
# к следующему элементу коллекции.

# Итерируемый объект - это объект, который позволяет поочередно обойти 
# свои элементы и пожет быть преобразован к итератору.

# Самый распространенный итерируемый объект - list
a = [1, 2, 3, 4, 5]
print(a, type(a))
# но мы не можем его обойти при помощи итератора используя next(а)
# так как список это не итератор. 
# Но любой итерируемый объект можно превратить в итератор -> iter(a)
# На выходе получаем объект-итератор списка
il = iter(a)
print(il, type(il)) 
# Теперь элементы списка можно обойти с помощью итератора 
next(il)
# При первом ее вызове она возвратит первое значение списка a и изменит
# позицию итератора it, переместив его на следующий элемент.

# Поэтому при втором вызове мы получим уже значение второго элемента
# и так до конца списка

# Если вызвать функцию next когда мы уже дошли до конца списка, 
# то она возвратит ошибку

b = (x**2 for x in range(10))
next(b)
print(b, type(b))
next(b)
print(b)

# переменную b можно воспринимать как итератор и перебирать список 
# через функцию next

# Итераторы очень удобно использовать в цикле for:
b = (x**2 for x in range(10))
for i in b:
   print(i)

# Здесь нам не нужно использовать функцию next для перехода к следующему 
# значению. Это автоматически выполняет оператор in в for. 
# Но использовать его можно только один раз.

# Некоторые функции такие как: min, max, sum позволяют работать 
# с итераторами.
b = (x**2 for x in range(10))
print(sum(b))

# У этих объектов есть одно существенное преимущество по сравнению с
# обычными списками: они не хранят в памяти все значения сразу, 
# а генерируют их по мере необходимости, то есть, при проходе к следующему 
# значению.

# И работать все это будет достаточно быстро, так как lst не хранит в 
# памяти элементы, а вычисляет их налету в цикле for. Правда, из-за этого
# нельзя определить число элементов в генераторе при помощи функции len:
# или получить доступ к отдельному списку по индексу

# Можно сделать обратную операцию преобразоваия в list
b = (x**2 for x in range(10))
c = list(b)
print(b, type(b))
print(c, type(c))

