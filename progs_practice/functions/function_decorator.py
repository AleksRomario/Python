#!/usr/bin/env python3 
import time

# Декоратор в Python – это функция, которая в качестве аргумента принимает
# другую функцию и расширяет ее функционал без изменения последней.
print("Декораторы функций")

# Алгоритм Евклида
def getNOD(a, b):
    while a != b:
        if a > b: a-= b
        else: b -= a
    return a

# Быстрый алгоритм Евклида
def getFastNOD(a, b):
    if a < b:
        a,b = b,a
    while b:
        a,b = b, a%b
    return a

# тест для проверки скорости работы этой функции.
# Реализуем этот тест в виде декоратора:

def testTime(fn):
    def wrapper(*args , **kwargs):
        st = time.time()
        fn(*args, **kwargs)
        dt = time.time() - st 
        print(f"Время работы : {dt} сек.")
    return wrapper

# внутри декоратора происходит вызов функции
# сам декоратор возвращает ссылку на функцию обертку

# декоратор testTime возвращает ссылку на wrapper, который в свою 
# очередь будет вызывать getNOD и определять время выполнения именно 
# этой функции при заданных аргументах.

result = testTime(getNOD)
print(type(result))
result(2, 1000000)

result2 = testTime(getFastNOD)
print(type(result2))
result2(2, 1000000)

# замыкание - когда вложенная функция ссылается на контекст внешней 
# функции и потому имеет возможность обращаться ко всем локальным 
# переменным этого внешнего контекста.


# Задание для самоподготовки:

# 1. Напишите две функции создания списка из четных чисел от 0 до N 
# (N – аргумент функции):
# [0, 2, 4, …, N]

# с помощью метода append и с помощью инструмента list comprehensions 
# (генератор списков). Через декоратор определите время работы этих функций.

# 2. Напишите декоратор для кэширования результатов работы функции 
# вычисления квадратного корня положительного целочисленного значения x. 
# То есть, при повторном вызове функции (через декоратор) с одним и 
# тем же аргументом, результат должен браться из кэша, а не вычисляться 
# заново. (Подсказка: здесь следует использовать замыкание для хранения 
# кэша).
